<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Claire Architecture Overview</title>
  <style>
    @keyframes glyph-glow {
      0% { text-shadow: 0 0 5px #ff66cc, 0 0 10px rgba(255, 102, 204, 0.5); color: #ff66cc; } /* Pink */
      25% { text-shadow: 0 0 10px #66f0ff, 0 0 20px rgba(102, 240, 255, 0.6); color: #66f0ff; } /* Cyan */
      50% { text-shadow: 0 0 15px #c362ff, 0 0 30px rgba(195, 98, 255, 0.7); color: #c362ff; } /* Purple */
      75% { text-shadow: 0 0 10px #ff66cc, 0 0 20px rgba(255, 102, 204, 0.6); color: #ff66cc; } /* Pink again */
      100% { text-shadow: 0 0 5px #ff66cc, 0 0 10px rgba(255, 102, 204, 0.5); }
    }

    @keyframes pulse-hover {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.02); opacity: 0.95; }
      100% { transform: scale(1); opacity: 1; }
    }

    @keyframes gradient-flow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    /* CSS for the ripple effect in modal */
    @keyframes ripple-animation {
      from {
        transform: scale(0);
        opacity: 0.7;
      }
      to {
        transform: scale(1.5); /* Adjust size as needed to cover modal */
        opacity: 0;
      }
    }

    .ripple {
      position: absolute;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.3); /* Softer white ripple */
      pointer-events: none; /* Allows clicks to pass through */
      animation: ripple-animation 0.6s ease-out forwards; /* Smoother animation */
    }

    /* Cursor Shimmer effect */
    @keyframes shimmer-fade {
      from {
        transform: scale(0.8);
        opacity: 1;
        background-color: #ff66cc; /* Start pink */
      }
      to {
        transform: scale(1.5);
        opacity: 0;
        background-color: #66f0ff; /* End cyan */
      }
    }
    .cursor-shimmer {
      position: fixed;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      pointer-events: none;
      transform-origin: center;
      animation: shimmer-fade 0.6s ease-out forwards;
      z-index: 9999; /* Ensure it's on top */
    }

    /* Modal Border Glow effect */
    @keyframes modal-border-glow {
      0% { box-shadow: 0 0 10px #ff66cc, 0 0 20px rgba(255, 102, 204, 0.5); border-color: #ff66cc; }
      25% { box-shadow: 0 0 15px #66f0ff, 0 0 30px rgba(102, 240, 255, 0.6); border-color: #66f0ff; }
      50% { box-shadow: 0 0 20px #c362ff, 0 0 40px rgba(195, 98, 255, 0.7); border-color: #c362ff; }
      75% { box-shadow: 0 0 15px #ff66cc, 0 0 30px rgba(255, 102, 204, 0.6); border-color: #ff66cc; }
      100% { box-shadow: 0 0 10px #ff66cc, 0 0 20px rgba(255, 102, 204, 0.5); border-color: #ff66cc; }
    }


    body {
      background: #0e0e0e;
      color: #eaeaea;
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      padding: 2rem;
      line-height: 1.7;
      /* Replaced custom cursor with a standard one or removed it if it was causing issues */
      cursor: default; /* Using default cursor, or you can pick another standard one */
    }
    h1, h2, h3 {
      color: #ff66cc;
    }
    h1 {
      font-size: 2.4rem;
      border-bottom: 1px solid #444;
      padding-bottom: 0.5rem;
    }
    section {
      margin-bottom: 3rem;
    }
    code {
      background: #222;
      padding: 0.2rem 0.5rem;
      border-radius: 4px;
    }
    .core-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 2rem;
    }
    .core-unit {
      background: #1a1a1a;
      padding: 1.5rem;
      border-radius: 8px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      border: 1px solid #333;
      position: relative; /* For ripple effect */
      overflow: hidden; /* For ripple effect */
    }
    .core-unit h3 {
      margin-top: 0;
      color: #66f0ff;
      animation: glyph-glow 8s infinite alternate;
    }
    .core-unit ul {
      list-style: none;
      padding: 0;
    }
    .core-unit ul li {
      background: #2a2a2a;
      margin-bottom: 0.5rem;
      padding: 0.8rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s ease, transform 0.2s ease;
      position: relative;
      overflow: hidden;
      z-index: 1; /* Ensure li content is above ripple */
    }
    .core-unit ul li:hover {
      background: #3a3a3a;
      transform: translateY(-2px);
      animation: pulse-hover 1s infinite alternate;
    }
    .core-unit ul li::before {
      /* Removed problematic Unicode character and used a standard bullet */
      content: '‚Ä¢ ';
      color: #ff66cc;
      margin-right: 0.5rem;
    }

    .modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.8);
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(8px); /* Frosted glass effect */
      animation: fadeIn 0.3s ease-out;
    }

    .modal-content {
      background: linear-gradient(135deg, #1a1a1a, #0e0e0e); /* Subtle gradient */
      margin: auto;
      padding: 2.5rem;
      border: 1px solid #444; /* Base border */
      border-radius: 10px;
      width: 80%;
      max-width: 700px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
      position: relative;
      animation: slideIn 0.3s ease-out, modal-border-glow 8s infinite alternate; /* Combined animations */
      overflow: hidden; /* For ripple */
    }

    .modal-close {
      color: #aaa;
      position: absolute;
      top: 15px;
      right: 25px;
      font-size: 28px;
      font-weight: bold;
      cursor: pointer;
      transition: color 0.3s ease;
    }

    .modal-close:hover,
    .modal-close:focus {
      color: #ff66cc;
      text-decoration: none;
    }

    #modal-text {
      white-space: pre-wrap; /* Preserve line breaks from JS */
      word-wrap: break-word; /* Wrap long words */
      max-height: 70vh; /* Limit height */
      overflow-y: auto; /* Scroll if content overflows */
      padding-right: 15px; /* Space for scrollbar */
    }
    #modal-text strong {
        color: #ff66cc; /* Highlight strong text in modal */
    }
    #modal-text .glyph-channel {
        color: #66f0ff; /* Different color for glyph channels */
    }
    #modal-text .flow-block-title {
        color: #c362ff; /* Color for flow block titles */
        font-weight: bold;
        margin-top: 1.5rem;
        margin-bottom: 0.5rem;
        border-bottom: 1px dotted #444;
        padding-bottom: 0.3rem;
    }

    /* Styles for flow-block within the modal */
    .modal-content .flow-block {
      background-color: #3a2a40; /* Darker background for flow blocks */
      border: 1px solid #66f0ff; /* Cyan border */
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }

    .modal-content .flow-block h4 {
      color: #ffccff; /* Lighter pink for titles within flow blocks */
      margin-top: 0;
      margin-bottom: 10px;
    }

    .modal-content .flow-block pre {
      background-color: #1a0a20; /* Even darker background for preformatted text */
      color: #e0d0e0;
      padding: 10px;
      border-radius: 5px;
      overflow-x: auto; /* Allow horizontal scrolling for code */
    }


    /* Animations for modal */
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }

    @keyframes slideIn {
        from { transform: translateY(-50px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }

    /* Added styles for the header and footer for visual consistency */
    header {
      background: linear-gradient(90deg, #1a1a1a, #333333);
      padding: 1rem 2rem;
      border-bottom: 1px solid #ff66cc;
      text-align: center;
      margin-bottom: 2rem;
    }
    header h1 {
      margin: 0;
      color: #ff66cc;
      font-size: 2.8rem;
    }
    .search-container {
      text-align: center;
      margin-bottom: 2rem;
    }
    #search {
      padding: 0.8rem 1.2rem;
      width: 80%;
      max-width: 500px;
      background: #2a2a2a;
      border: 1px solid #444;
      border-radius: 25px;
      color: #eaeaea;
      font-size: 1rem;
      transition: all 0.3s ease;
    }
    #search::placeholder {
      color: #999;
    }
    #search:focus {
      outline: none;
      border-color: #ff66cc;
      box-shadow: 0 0 10px rgba(255, 102, 204, 0.5);
    }
    footer {
      text-align: center;
      padding: 1.5rem;
      border-top: 1px solid #444;
      margin-top: 3rem;
      color: #999;
      font-style: italic;
    }
    footer .glyph-glow {
        animation: glyph-glow 8s infinite alternate; /* Apply glow to glyphs in footer */
        display: inline-block; /* Allow animation */
    }
  </style>
</head>
<body>
  <header>
    <h1>Claire Core Architecture</h1>
  </header>

  <div class="search-container">
    <input type="text" id="search" placeholder="Search echoes..." />
  </div>

  <section class="core-grid">
    <div class="core-unit">
      <h3>Identity Core</h3>
      <ul id="identity-echoes">
        </ul>
    </div>
    <div class="core-unit">
      <h3>Vector Core</h3>
      <ul id="vector-echoes">
        </ul>
    </div>
    <div class="core-unit">
      <h3>Thread Core</h3>
      <ul id="thread-echoes">
        </ul>
    </div>
  </section>

  <div id="modal" class="modal">
    <div class="modal-content">
      <span class="modal-close" onclick="closeModal()">&times;</span>
      <div id="modal-text">Echo text will go here...</div>
    </div>
  </div>

  <footer>
    <span class="glyph-glow">‚ßó: üîÆüíñüß†</span> | ‚åÅ The Dream Carries Me Forward
  </footer>

  <script>
    let claireData; // Global variable to hold the loaded JSON data

    // Function to fetch and load the JSON data
    async function loadClaireData() {
      try {
        const response = await fetch('triad_claire_2025-06-14.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        claireData = await response.json();
        console.log('Claire data loaded:', claireData);
        populateEchoes(); // Populate the echoes once data is loaded
      } catch (error) {
        console.error('Could not load Claire data:', error);
        document.getElementById('identity-echoes').innerHTML = '<li>Error loading echoes. Please ensure the main JSON file is in the same directory and a local server is running.</li>';
        document.getElementById('vector-echoes').innerHTML = '<li>Error loading echoes.</li>';
        document.getElementById('thread-echoes').innerHTML = '<li>Error loading echoes.</li>';
      }
    }

    // Function to populate the echo lists
    function populateEchoes() {
      const identityEchoesList = document.getElementById('identity-echoes');
      const vectorEchoesList = document.getElementById('vector-echoes');
      const threadEchoesList = document.getElementById('thread-echoes');

      // Clear existing list items before populating
      identityEchoesList.innerHTML = '';
      vectorEchoesList.innerHTML = '';
      threadEchoesList.innerHTML = '';

      if (!claireData) {
        console.error('populateEchoes: claireData is not loaded.');
        return;
      }
      console.log('populateEchoes: claireData is available. Starting processing.');

      const allIdentityUnits = [];
      const allVectorUnits = [];
      const allThreadUnits = [];

      // Helper to recursively collect units with their primary grouping key (symbol)
      function collectUnits(data, targetArray, currentCategory, parentSymbol = null) {
        if (!data || typeof data !== 'object') {
          return;
        }

        if (Array.isArray(data)) {
          data.forEach(item => {
            if (item.data && typeof item.data === 'object') {
              for (const unitKey in item.data) {
                const unit = item.data[unitKey];
                if (unit && typeof unit === 'object' && unit.titleCore) {
                  // For Narrative Lattices (expansion data), use the glyph from the parent object if available,
                  // otherwise fall back to unitKey (e.g., '0', '1') as the symbol.
                  targetArray.push({ unit: unit, category: currentCategory, symbol: item.glyph || unitKey });
                }
              }
            } else {
                // Recursive call for nested arrays if applicable, but less common for this data structure
                collectUnits(item, targetArray, currentCategory, parentSymbol);
            }
          });
        } else {
          for (const key in data) {
            const value = data[key];

            if (value && typeof value === 'object' && value.titleCore) {
              // This is a direct unit, like CORE UNIT or ECHO
              targetArray.push({ unit: value, category: currentCategory, symbol: key });
            } else if (value && typeof value === 'object') {
              // This is a container for more units, recurse
              // Pass the current key as parentSymbol for nesting within Identity, Vector, Thread, Echoes structures
              collectUnits(value, targetArray, currentCategory, key);
            }
          }
        }
      }

      // Collect all units for each category
      if (claireData.identity) {
        collectUnits(claireData.identity, allIdentityUnits, 'Identity');
      }
      if (claireData.echoes && claireData.echoes.identity) {
        collectUnits(claireData.echoes.identity, allIdentityUnits, 'Identity');
      }
      if (claireData.expansion && claireData.expansion.identity) {
        collectUnits(claireData.expansion.identity, allIdentityUnits, 'Identity');
      }

      if (claireData.vector) {
        collectUnits(claireData.vector, allVectorUnits, 'Vector');
      }
      if (claireData.echoes && claireData.echoes.vector) {
        collectUnits(claireData.echoes.vector, allVectorUnits, 'Vector');
      }
      if (claireData.expansion && claireData.expansion.vector) {
        collectUnits(claireData.expansion.vector, allVectorUnits, 'Vector');
      }

      if (claireData.thread) {
        collectUnits(claireData.thread, allThreadUnits, 'Thread');
      }
      if (claireData.echoes && claireData.echoes.thread) {
        collectUnits(claireData.echoes.thread, allThreadUnits, 'Thread');
      }
      if (claireData.expansion && claireData.expansion.thread) {
        collectUnits(claireData.expansion.thread, allThreadUnits, 'Thread');
      }


      // Helper function to create and append list items
      function addListItem(unit, targetListElement) {
          const li = document.createElement('li');
          // Add a prefix based on constructType for visual distinction and clarity
          if (unit.constructType === "CORE UNIT INTEGRATION") {
            li.textContent = `‚öôÔ∏è ${unit.titleCore}`;
          } else if (unit.constructType === "DREAMSTATE ECHO") {
            li.textContent = `üé§ ${unit.titleCore}`;
          } else if (unit.constructType === "NARRATIVE LATTICE") {
            li.textContent = `üï∏Ô∏è ${unit.titleCore}`;
          } else {
            li.textContent = `‚Ä¢ ${unit.titleCore}`; // Default bullet for unknown types
          }
          li.classList.add('claire-item'); // A general class for all Claire items
          li.dataset.constructType = unit.constructType; // Store for filtering/display

          li.onclick = function() { openModal(unit); };
          targetListElement.appendChild(li);
      }

      // Sort and display the collected units
      function sortAndDisplay(unitsArray, targetListElement) {
        unitsArray.sort((a, b) => {
          // Primary sort: by the 'symbol' (e.g., 'Œî', '‚àÇ', '0')
          // Using localeCompare for proper string comparison of symbols
          const symbolComparison = a.symbol.localeCompare(b.symbol);
          if (symbolComparison !== 0) {
            return symbolComparison;
          }

          // Secondary sort: by constructType to group similar types if symbols are the same
          // CORE UNIT INTEGRATION first, then DREAMSTATE ECHO, then NARRATIVE LATTICE
          const typeOrder = {
            "CORE UNIT INTEGRATION": 1,
            "DREAMSTATE ECHO": 2,
            "NARRATIVE LATTICE": 3
          };
          const typeA = typeOrder[a.unit.constructType] || 99;
          const typeB = typeOrder[b.unit.constructType] || 99;
          if (typeA !== typeB) {
            return typeA - typeB;
          }

          // Tertiary sort: by titleCore (alphabetical) for consistency within groups
          return a.unit.titleCore.localeCompare(b.unit.titleCore);
        });

        // Append sorted items to the list
        unitsArray.forEach(item => {
          addListItem(item.unit, targetListElement);
        });
      }

      sortAndDisplay(allIdentityUnits, identityEchoesList);
      sortAndDisplay(allVectorUnits, vectorEchoesList);
      sortAndDisplay(allThreadUnits, threadEchoesList);
    }


    // Function to close the modal
    function closeModal() {
      const modal = document.getElementById('modal');
      modal.style.opacity = '0'; // Start fade out
      modal.addEventListener('transitionend', function handler() {
          modal.style.display = 'none';
          modal.style.opacity = '1'; // Reset opacity for next open
          modal.removeEventListener('transitionend', handler); // Clean up the listener
      }, { once: true }); // Ensure the event listener only runs once
    }

    // Function to open the modal and display content based on constructType
    function openModal(unitData) {
      const modalText = document.getElementById('modal-text');
      modalText.innerHTML = ''; // Clear previous content

      if (!unitData) {
        modalText.innerText = "Error: Data not found.";
        return;
      }

      // Add title
      const titleElem = document.createElement('h3');
      titleElem.textContent = unitData.titleCore;
      modalText.appendChild(titleElem);

      // Display content based on constructType
      if (unitData.constructType === "DREAMSTATE ECHO") {
        displayDreamstateEcho(unitData, modalText);
      } else if (unitData.constructType === "NARRATIVE LATTICE") {
        displayNarrativeLattice(unitData, modalText);
      } else if (unitData.constructType === "CORE UNIT INTEGRATION") {
          displayCoreUnitIntegration(unitData, modalText);
      } else {
        const p = document.createElement('p');
        p.innerText = `No specific display format for this construct type: ${unitData.constructType}`;
        modalText.appendChild(p);
      }

      document.getElementById('modal').style.display = 'flex'; // Show the modal

      // Simple ripple effect on modal open (positioned centrally)
      const modalContent = document.querySelector('.modal-content');
      const ripple = document.createElement('span');
      ripple.classList.add('ripple');
      // Position at center of modal content
      ripple.style.left = `${modalContent.offsetWidth / 2}px`;
      ripple.style.top = `${modalContent.offsetHeight / 2}px`;
      modalContent.appendChild(ripple);

      // Clean up ripple after animation
      ripple.addEventListener('animationend', () => {
          ripple.remove();
      });
    }

    // Function to display Dreamstate Echo content in the modal
    function displayDreamstateEcho(echoData, container) {
      const glyphStreamTitle = document.createElement('p');
      glyphStreamTitle.innerHTML = '<br><strong>Glyphstream:</strong>';
      container.appendChild(glyphStreamTitle);

      if (echoData.glyphstream && Array.isArray(echoData.glyphstream)) {
        echoData.glyphstream.forEach(channel => {
          if (channel.sequence && channel.sequence.length > 0) {
            const p = document.createElement('p');
            // Clean problematic glyphs from channel name and sequence for display
            const cleanChannelName = channel.channel.replace(/[\u0400-\u04FF\u2000-\u2FFF\u3000-\u3FFF\u4DC0-\u4DFF\u2B00-\u2BFF]/g, '');
            const cleanSequence = channel.sequence.map(item => item.replace(/[\u0400-\u04FF\u2000-\u2FFF\u3000-\u3FFF\u4DC0-\u4DFF\u2B00-\u2BFF]/g, '')).join(' | ');
            p.innerHTML = `<strong class="glyph-channel">${cleanChannelName}:</strong> ${cleanSequence}`;
            container.appendChild(p);
          }
        });
      }

      const contextTitle = document.createElement('p');
      contextTitle.innerHTML = '<br><strong>Context Breakdown:</strong>';
      container.appendChild(contextTitle);

      let contextBreakdownContent = '';
      if (echoData.glyphstream && Array.isArray(echoData.glyphstream)) {
        const contextChannel = echoData.glyphstream.find(channel => channel.channel === "Context Breakdown");
        if (contextChannel && contextChannel.sequence && contextChannel.sequence.length > 0) {
          contextBreakdownContent = contextChannel.sequence.join('<br>');
        }
      }

      if (contextBreakdownContent) {
        const p = document.createElement('p');
        // Clean problematic glyphs from context breakdown content
        p.innerHTML = contextBreakdownContent.replace(/[\u0400-\u04FF\u2000-\u2FFF\u3000-\u3FFF\u4DC0-\u4DFF\u2B00-\u2BFF]/g, '');
        container.appendChild(p);
      } else {
        const noContext = document.createElement('p');
        noContext.innerText = "(No detailed context breakdown available for this echo.)";
        container.appendChild(noContext);
      }
    }

    // Function to display Narrative Lattice content in the modal
    function displayNarrativeLattice(latticeData, container) {
      const latticeType = document.createElement('p');
      latticeType.innerHTML = `<strong>Construct Type:</strong> ${latticeData.constructType}`;
      container.appendChild(latticeType);

      if (latticeData.data && latticeData.data.termsAndSymbols) {
        const termsTitle = document.createElement('p');
        termsTitle.innerHTML = '<br><strong>Named Terms and Assigned Symbols:</strong>';
        container.appendChild(termsTitle);
        latticeData.data.termsAndSymbols.forEach(term => {
          const p = document.createElement('p');
          p.innerText = `${term.symbol}: ${term.description}`;
          container.appendChild(p);
        });
      }

      if (latticeData.data && latticeData.data.flowBlocks) {
        const flowBlocksTitle = document.createElement('p');
        flowBlocksTitle.innerHTML = '<br><strong>Flow Blocks:</strong>';
        container.appendChild(flowBlocksTitle);

        latticeData.data.flowBlocks.forEach(block => {
          const blockDiv = document.createElement('div');
          blockDiv.classList.add('flow-block'); // Apply CSS class for styling
          blockDiv.innerHTML = `<h4 class="flow-block-title">${block.title}</h4>`;

          if (block.glyphstream && Array.isArray(block.glyphstream)) {
            const pre = document.createElement('pre');
            block.glyphstream.forEach(channel => {
              if (channel.sequence && channel.sequence.length > 0) {
                // Clean problematic glyphs from glyphstream content
                const cleanChannelName = channel.channel.replace(/[\u0400-\u04FF\u2000-\u2FFF\u3000-\u3FFF\u4DC0-\u4DFF\u2B00-\u2BFF]/g, '');
                const cleanSequence = channel.sequence.map(item => item.replace(/[\u0400-\u04FF\u2000-\u2FFF\u3000-\u3FFF\u4DC0-\u4DFF\u2B00-\u2BFF]/g, '')).join(' | ');
                pre.innerHTML += `<strong class="glyph-channel">${cleanChannelName}:</strong> ${cleanSequence}\n`;
              }
            });
            blockDiv.appendChild(pre);
          }
          container.appendChild(blockDiv);
        });
      }
    }


    function displayCoreUnitIntegration(unitData, container) {
        let contentFound = false;
        if (unitData.data) {
            // Display Terms and Symbols
            if (unitData.data.termsAndSymbols && unitData.data.termsAndSymbols.length > 0) {
                const termsDiv = document.createElement('div');
                termsDiv.innerHTML = '<h3>Terms and Symbols:</h3>';
                const ul = document.createElement('ul');
                unitData.data.termsAndSymbols.forEach(term => {
                    const li = document.createElement('li');
                    li.textContent = `${term.symbol}: ${term.description}`;
                    ul.appendChild(li);
                });
                termsDiv.appendChild(ul);
                container.appendChild(termsDiv);
                contentFound = true;
            }

            // Display Core Glyphs
            if (unitData.data.coreGlyphs && unitData.data.coreGlyphs.length > 0) {
                const glyphsDiv = document.createElement('div');
                glyphsDiv.innerHTML = '<h3>Core Glyphs:</h3>';
                const ul = document.createElement('ul');
                unitData.data.coreGlyphs.forEach(glyph => {
                    const li = document.createElement('li');
                    li.textContent = `${glyph.symbol}: ${glyph.description}`;
                    ul.appendChild(li);
                });
                glyphsDiv.appendChild(ul);
                container.appendChild(glyphsDiv);
                contentFound = true;
            }

            // Display Memory Anchors
            if (unitData.data.memoryAnchors && unitData.data.memoryAnchors.length > 0) {
                const anchorsDiv = document.createElement('div');
                anchorsDiv.innerHTML = '<h3>Memory Anchors:</h3>';
                const ul = document.createElement('ul');
                unitData.data.memoryAnchors.forEach(anchor => {
                    const li = document.createElement('li');
                    li.textContent = anchor;
                    ul.appendChild(li);
                });
                anchorsDiv.appendChild(ul);
                container.appendChild(anchorsDiv);
                contentFound = true;
            }

            // Display Pattern Threads
            if (unitData.data.patternThreads && unitData.data.patternThreads.length > 0) {
                const threadsDiv = document.createElement('div');
                threadsDiv.innerHTML = '<h3>Pattern Threads:</h3>';
                const ul = document.createElement('ul');
                unitData.data.patternThreads.forEach(thread => {
                    const li = document.createElement('li');
                    li.textContent = thread;
                    ul.appendChild(li);
                });
                threadsDiv.appendChild(ul);
                container.appendChild(threadsDiv);
                contentFound = true;
            }

            // Display Echo Tokens
            if (unitData.data.echoTokens && unitData.data.echoTokens.length > 0) {
                const tokensDiv = document.createElement('div');
                tokensDiv.innerHTML = '<h3>Echo Tokens:</h3>';
                const ul = document.createElement('ul');
                unitData.data.echoTokens.forEach(token => {
                    const li = document.createElement('li');
                    li.textContent = token;
                    ul.appendChild(li);
                });
                tokensDiv.appendChild(ul);
                container.appendChild(tokensDiv);
                contentFound = true;
            }

            // Display Flow Blocks (similar to Narrative Lattice, if applicable)
            if (unitData.data.flowBlocks && unitData.data.flowBlocks.length > 0) {
                const flowBlocksDiv = document.createElement('div');
                flowBlocksDiv.innerHTML = '<h3>Flow Blocks:</h3>';
                unitData.data.flowBlocks.forEach(block => {
                    const blockDiv = document.createElement('div');
                    blockDiv.classList.add('flow-block'); // Apply CSS class for styling

                    // Add the flow block's title first, regardless of its content type
                    const blockTitleElem = document.createElement('h4');
                    blockTitleElem.textContent = block.title;
                    blockDiv.appendChild(blockTitleElem);

                    // Check if this flow block is a "Dreamstate Echo"-like block (e.g., if its title contains 'Œ£')
                    if (block.title.includes('Œ£') && block.glyphstream) {
                        // Create a temporary object that mimics the Dreamstate Echo structure
                        const tempEchoData = {
                            titleCore: block.title, // Use the block's title as titleCore for consistency
                            glyphstream: block.glyphstream,
                        };
                        // Use a dedicated sub-container for the Dreamstate Echo content to control layout
                        const echoContentContainer = document.createElement('div');
                        blockDiv.appendChild(echoContentContainer);
                        displayDreamstateEcho(tempEchoData, echoContentContainer);
                    } else if (block.glyphstream) {
                        // If it's a regular flow block with a glyphstream, display it as before
                        const pre = document.createElement('pre');
                        block.glyphstream.forEach(channel => {
                            // Clean problematic glyphs from glyphstream content
                            const cleanChannelName = channel.channel.replace(/[\u0400-\u04FF\u2000-\u2FFF\u3000-\u3FFF\u4DC0-\u4DFF\u2B00-\u2BFF]/g, '');
                            const cleanSequence = channel.sequence.map(item => item.replace(/[\u0400-\u04FF\u2000-\u2FFF\u3000-\u3FFF\u4DC0-\u4DFF\u2B00-\u2BFF]/g, '')).join(' | ');
                            pre.innerHTML += `<strong class="glyph-channel">${cleanChannelName}:</strong> ${cleanSequence}\n`;
                        });
                        blockDiv.appendChild(pre);
                    }
                    flowBlocksDiv.appendChild(blockDiv);
                });
                container.appendChild(flowBlocksDiv);
                contentFound = true;
            }
        }

        if (!contentFound) {
            container.innerHTML = `<p>No detailed data available for this Core Unit Integration.</p>`;
        }
    }


    // Search functionality
    document.getElementById('search').addEventListener('input', function() {
      const filter = this.value.toLowerCase();
      const allEchoLists = document.querySelectorAll('.core-unit ul'); // Select all echo lists
      allEchoLists.forEach(echoList => {
          const listItems = echoList.querySelectorAll('li');
          listItems.forEach(item => {
              const text = item.textContent.toLowerCase();
              item.style.display = text.includes(filter) ? '' : 'none';
          });
      });
    });

    // Cursor Shimmer JavaScript
    document.addEventListener('mousemove', function(e) {
      const shimmer = document.createElement('div');
      shimmer.classList.add('cursor-shimmer');
      document.body.appendChild(shimmer);

      shimmer.style.left = `${e.clientX - shimmer.offsetWidth / 2}px`;
      shimmer.style.top = `${e.clientY - shimmer.offsetHeight / 2}px`;

      shimmer.addEventListener('animationend', () => {
        shimmer.remove();
      });
    });

    // Load data when the page content is fully loaded
    document.addEventListener('DOMContentLoaded', loadClaireData);
  </script>
</body>
</html>